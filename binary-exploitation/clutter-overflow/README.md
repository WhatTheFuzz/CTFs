# Clutter-Overflow

## Introduction

Clutter-overflow is a 150 point binary exploitation problem from picoCTF. The description states:

> Clutter, clutter everywhere and not a byte to use.
> `nc mars.picoctf.net 31890`

We are given the source, the compiled executable, and the address:port to connect on.

## Information Gathering

No hints were given, but we do have source code.

### Vulnerability Mitigations

```shell
$ checksec chall
[*] '/home/sean/Dev/picoCTF/binary-exploitation/clutter-overflow/chall'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)

```

### Static

At the top, there is a header defined obnoxiously to make some sort of ASCII art. It looks like a living room. There is only one function, `main`, and it instantiates an integer and a buffer of size 0x100 onto the stack called `clutter`, prints out the header ascii art, and calls `gets` to place user input into `clutter`. It then checks if the integer located above the `clutter` buffer on the stack is equivalent to `0xdeadbeef`. If so, the remote server will print out the flag for us.

### Dynamic

If we run the program with a simple input that will cause a segmentation error we get the following result:

```
My room is so cluttered...
What do you see?
$ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
code == 0x6161616161616161
```

Because it tells us the value of `code`, we can easily determine the offset. This means we don't even need to touch a debugger. Nice!

## Strategy

`gets` is a bad function. Even the `man` page tells you not to use it (actually). Let's send a cyclic pattern to `gets` and observe what the result of the integer `code` is. We should overwrite this value and from there we can calculate our offset to `code` on the stack. Once we know the offset, we can send `0xdeadbeef` and get our flag.
