# Guessing Game #1

## Introduction

Guessing Game #1 is a 250 point binary-exploitation challenge from picoCTF. The description states:

> I made a simple game to show off my programming skills. See if you can beat it!

We get the executable, the Makefile, and the source.

## Information Gathering

### Hint #1

> Tools can be helpful, but you may need to look around for yourself.

Pretty ambiguous I think. I am not sure what to make of this.

### Hint #2

> Remember, in CTF problems, if something seems weird it probably means something...

Also pretty ambiguous, but I guess we should dive in!

### Vulnerability Mitigations

```shell
$ checksec vuln
    Arch:     amd64-64-little
    RELRO:    Partial RELRO
    Stack:    Canary found
    NX:       NX enabled
    PIE:      No PIE (0x400000)
```

The Makefile suggests no stack canary given the `-fno-stack-protector` flag. We confirm it is not PIE. It's also statically linked which is neat and give us an opportunity to do relative jumps easier.

Using `objdump --syms` I didn't see symbols for `system` or `exec*`, so I am guessing that either the remote server is going to read the flag for us or we need some shellcode. Current thoughts anyways. We need to check the source first.

### Source

`main` is essentially the following loop:

```c
while (1) {
res = do_stuff();
if (res) {
    win();
}
```

`do_stuff` gets a random number using `rand`. Note that it is never seeded using `srand`. `man 3 rand` states that this means it will always have a default seed of 1:

> If no seed value is provided, the rand() function is automatically seeded with a value of 1.

So our random number is not so random; we will get the same number each time. We should be able to figure it out with GDB.


```c
int do_stuff() {
	long ans = get_random();
	ans = increment(ans);
	int res = 0;

	printf("What number would you like to guess?\n");
	char guess[BUFSIZE];
	fgets(guess, BUFSIZE, stdin);

	long g = atol(guess);
	if (!g) {
		printf("That's not a valid number!\n");
	} else {
		if (g == ans) {
			printf("Congrats! You win! Your prize is this print statement!\n\n");
			res = 1;
		} else {
			printf("Nope!\n\n");
		}
	}
	return res;
}
```

Continuing on, we see that if we 'win' we get to the following function. And we can spot the bug. The developer should have limited the call to `fgets` to BUFSIZE (which is a macro for 100), but it is instead 360. So if we get to the `win` function we should be able to overflow the buffer and overrun the return address. Cool, lets do that.

```c
void win() {
	char winner[BUFSIZE];
	printf("New winner!\nName? ");
	fgets(winner, 360, stdin);
	printf("Congrats %s\n\n", winner);
}
```

## Solving

If we set a breakpoint on increment (we have symbols, thank you developers!) we can inspect what the expected number is that we need to guess, 0x54 or 84.

```gdb
break increment
finish
p/d $rax
$1 = 84
```
