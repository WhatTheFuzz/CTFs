# Cache Me Outside

## Introduction

Cache me Outside is the second challenge in the binary exploitation category. The description states:

> While being super relevant with my meme references, I wrote a program to see how much you understand heap allocations. nc mercury.picoctf.net 34499 heapedit Makefile libc.so.6

## Information Gathering

### Hint #1

> It may be helpful to read a little bit on GLIBC's tcache.

Before I looked at this challenge, I had no idea what the tcache was. Having only read through it a couple times, I would do a much poorer explanation than the blogs I found [here][azeria] and [here][azeria]. Essentially, the tcache is one of five types of bins that the heap manager keeps track of. The tcache is a per-thread cache that is used to immediately service an allocation without needing to wait on a heap lock when a thread requests memory. When a chunk of memory is freed, providing it it not null and is a valid address, it will be placed in the tcache if it fits (otherwise it could be `munmmap`'ed or stored in a different bin tracked by the heap manager). If we later request a chunk of the same size, we will retrieve the one we `free`'d earlier. This is where things could get hairy because the data at those memory location aren't erased, they are just marked as free for use. So if we have the ability to look into the tcache, we might see data that the developer didn't want us to see.

### Running the Program

We did not get source code for the challenge. We instead got the compiled amd64 executable, a copy of `libc` that is was linked against, and the Makefile. When we tried to execute the program we got an error:

```bash
$ ./heapedit
Inconsistency detected by ld.so: dl-call-libc-early-init.c: 37: _dl_call_libc_early_init: Assertion `sym != NULL' failed!
```

We got this error because the dynamic linker that was used to link this version of libc does not exist on our host. The solution then was to grab the correct version. Knowing the naming convention of libraries and the current version of libc (2.33 on our host), we `grep`ed for the version:

```bash
$ strings libc.so.6 | grep "2.2"
...
GNU C Library (Ubuntu GLIBC 2.27-3ubuntu1.2) stable release version 2.27.
libc-2.27.so
```

Cool, we found out it was 2.27. Now we need to grab that version. We downloaded it from a random GitHub account (which probably is not a great idea?), but left the link out for reasons. Alternatively, we cheated a bit and looked at a fantastic [writeup][writeup] and learned about `pwninit` which allowed us to download the correct version automatically.

```bash
$ pwninit
bin: ./heapedit
libc: ./libc.so.6

fetching linker
unstripping libc
warning: failed unstripping libc: failed running eu-unstrip, please install elfutils: No such file or directory (os error 2)
setting ./ld-2.27.so executable
running patchelf on ./heapedit_patched
```

We ran it again with the correct linker and provided version libc (you can also LD_PRELOAD these instead of using `pwninit`, but I really like it so far). However, we ran into a segmentation fault:

```bash
$ ./heapedit
qemu: uncaught target signal 11 (Segmentation fault) - core dumped
Segmentation fault (core dumped)
```

I had to use QEMU in this case because I'm running an ARM VM, so this is likely not needed for others. Running QEMU with the `--strace` option showed us that the fault was a bad read when trying to `open flag.txt`:

```bash
$ qemu-x86_64-static --strace ./heapedit
...
26026 openat(-100,"flag.txt",O_RDONLY) = -1 errno=2 (No such file or directory)
--- SIGSEGV {si_signo=SIGSEGV, si_code=1, si_addr=NULL} ---
```

We `echo`ed some random data into a new file called `flag.txt`. When we reran the program, it worked as intended. Whew, that was a lot of effort to just get the executable running. When we ran the program, this is what we got:

```text
$ ./heapedit
You may edit one byte in the program.
Address: 40000
Value: test
t help you: this is a random string.
```

[azeria]: https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/
[nightmare]: https://azeria-labs.com/heap-exploitation-part-2-glibc-heap-free-bins/
[writeup]:
