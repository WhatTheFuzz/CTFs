# Here's a LIBC

## Introduction

Here's a LIBC is the third challenge in the binary exploitation category. The description states:

> I am once again asking for you to pwn this binary vuln libc.so.6 Makefile nc mercury.picoctf.net 49464

It provides links to the vulnerable executable, a specific libc libray, and the Makefile.

## Information Gathering

### Hint #1

> PWNTools has a lot of useful features for getting offsets.

Hmm...this sounds like maybe we need to know the offset to something in libc. I guess we won't know unless we keep diving in!

### Glibc

Since it's in the title, it must be important. Let's figure out what version of libc we are dealing with:

![grep](./resources/grep.svg)

As we learned in the last challenge we did, Cache Me Outside, glibc 2.27 was the version after per-thread caches were introduced. We don't really know much more than that at the moment, though.

### Security settings

`Checksec`, a great program included with `pwntools`, gives us this information about the program `vuln` (though we also have the `Makefile` so we could look there).

![checksec](./resources/checksec.svg)

The lack of vulnerability mitigations opens up a bunch of doors like smashing the stack or ROP/JOP. The stack is not executable, so I'm going to guess we need to execute inside of libc for this challenge. The executable is also not stripped which should make decompilation and debugging easier.

### Running the Program

We need a matching version of the dynamic linker. We can get that with `pwninit` or download it off of some random website. I prefer the former.

![pwninit](./resources/pwninit.svg)

This will download our linker and patch our executable to use the libc version it shipped with and the new linker. We can then run the patched binary to see that it contains an echo server that capitalizes every other character:

![run](./resources/run.svg)

### Ghidra

To get a sense of what is going on, let's examine it in Ghidra.

We start by examining `main`, which we quickly find is not that interesting. `main` will initialize some stuff, print out the welcome message, and then loop infinitely calling `do_stuff`, as shown below:

![main](./resources/main.svg)

The function `do_stuff`, on the other hand, asks for user input via a `scanf` and stores the input in a 112 byte stack-based buffer. The bounds of this buffer is never checked. Rather, the `scanf` will continue to take input until a new-line character is provided. This allows the user to overflow the buffer and adjust contents on the stack. After reading in user input, the function loops over the first 100 characters and calls `convert_case` to presumably have an uppercase character followed by a lowercase character. All bytes in the buffer after index 100 are not adjusted. Finally, the function calls `puts` to show the user the buffer after it has been converted.
