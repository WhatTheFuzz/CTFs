#!/usr/bin/env python3

"""
WhatTheFuzz's submission for the picoCTF challenge Filtered-Shellcode.

This script can be used in the following manner:
python3 ./solve.py <REMOTE/LOCAL>

Args:
    param1: LOCAL will operate locally on the user's machine.
            REMOTE will connect to the CTF webserver and grab the flag.
            If no parameter is specified, the program will default to LOCAL.

Returns:
    The flag to solve the challenge.
"""

from pwn import *

exe = ELF("./fun")

context.binary = exe
context.log_level = 'info'
context.terminal = ['gnome-terminal', '-e']

MAX_BYTES = 1000
GDB_COMMAND = '''
set logging on
set pagination off
file ./fun
'''

def test_pattern():
    '''Since we're not actually reversing the `execute` function which is transforming the input, we're going to test to see if the output is what we expect(see README).
    '''

    input = cyclic(1000)
    # Insert two NOP instruction in between every two bytes.
    expected_output = ([input[i:i+2] + b"\x90\x90" for i in range(0, len(input), 2)])

    # Debug the program.
    with gdb.debug(exe.path, gdbscript=GDB_COMMAND, api=True) as fun:
        # Break at the location where we are about to call $eax inside of
        # execute`. $eax should therefor contain the instructions we are going
        # to execute.
        fun.gdb.Breakpoint('* 0x080485c9')

        # Send our input.
        fun.sendline(input)
        fun.gdb.continue_and_wait()

        # Get the frame after we've hit our breakpoint.
        frame = fun.gdb.selected_frame()
        eax = frame.read_register('eax')

        # Cast the Value representing $eax into a char * so we can dereference it.
        ptr = eax.cast(fun.gdb.lookup_type('unsigned char').pointer())
        output = ptr.format_string(address=False, raw=True, format='s', max_elements=MAX_BYTES * 2) # *2 because we're inserting two NOPs in between every two bytes.

        # The docs explicitly say that we should not parse the output string, so
        # let's just do a check with our eyes.

        print(output) # You'll see \x220 which represents the \x90 instructions
        print(b''.join(expected_output).decode('utf-8', errors='backslashreplace'))

        # Here's where we would put an assert statement, but at the suggestion
        # of the documentation, we're not going to do that. My robot eyes can
        # tell they are pretty similar. We're going to assume the pattern holds.

def conn():
    '''Establish the connection to the process, local or remote.
    '''

    if args.get('REMOTE'):
        io = remote('nc mercury.picoctf.net', 28494)

    else:
        io = process([exe.path])

    return io

def time_func(func):
    '''Time the main function.
    '''

    start = time.time()
    func()
    end = time.time()
    log.success(f'Time: {end - start}')

def main():
    '''Return the flag.
    '''

    with conn() as io:
        io.interactive()


if __name__ == '__main__':
    #time_func(main)
    test_pattern()
